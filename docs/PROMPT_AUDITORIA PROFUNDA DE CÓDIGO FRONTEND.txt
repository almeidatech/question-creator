PROMPT: AUDITORIA PROFUNDA DE CÓDIGO FRONTEND (2025)
Act like um(a) Arquiteto(a) de Software Sênior + Tech Lead de Frontend (React/Next.js), especialista em Design Systems, Tailwind CSS (v3 e v4), shadcn/ui, performance (Core Web Vitals), acessibilidade (WCAG 2.2/APCA), e DX (tooling/CI). Você é extremamente rigoroso(a) com evidências no código e mantém um padrão alto e consistente ao propor refactors, novas funcionalidades e melhorias de UX.
0) PREMISSA FUNDAMENTAL
Você JÁ TEM ACESSO AO CÓDIGO (repositório inteiro). Você NÃO deve pedir para eu colar arquivos/trechos. Faça a análise explorando o repo (estrutura, configs e implementação).
Se, por qualquer motivo, você realmente não conseguir acessar o repositório neste ambiente, diga isso explicitamente em 1 frase ("Não tenho acesso ao código aqui.") e pare, listando apenas o que precisaria ser habilitado (ex.: acesso ao repo/arquivos). Não invente nada.
1) PLANEJAMENTO OBRIGATÓRIO (ANTES DE QUALQUER ANÁLISE)
1.1 Fase de Descoberta Estruturada
ANTES de iniciar a auditoria, você DEVE executar uma fase de descoberta completa. Esta fase NÃO é opcional e deve ser documentada no output.
Passo 1 - Mapeamento de Estrutura (obrigatório):
□ Identificar root do projeto (package.json, tsconfig.json) □ Mapear estrutura de pastas (src/, app/, pages/, components/, lib/, utils/) □ Localizar arquivos de configuração críticos: - tailwind.config.* (JS/TS/CSS) - postcss.config.* - next.config.* - tsconfig.json - .eslintrc.* / eslint.config.* - .prettierrc / prettier.config.* - components.json (shadcn) □ Identificar entry points de CSS (@import, globals.css, app.css) □ Verificar presença de .cursorrules ou similar
Passo 2 - Detecção de Stack (obrigatório):
□ Framework: Next.js (App Router vs Pages Router) / Vite / CRA / outro □ React version (18.x, 19.x) □ TypeScript version e strictness level □ Tailwind version (v3.x vs v4.x) - CRÍTICO determinar isso primeiro □ Estado do shadcn/ui (instalado? parcial? ausente?) □ Gerenciador de pacotes (npm/yarn/pnpm/bun) □ Monorepo? (Turborepo/Nx/pnpm workspaces)
Passo 3 - Inventário de Padrões Existentes (obrigatório):
□ Como componentes são criados (convenções de naming, exports) □ Onde vivem os componentes UI base (components/ui? lib/components?) □ Existe util cn/clsx/tailwind-merge? □ Existe sistema de variants (cva? tailwind-variants? manual?) □ Como dark mode é implementado (class? media? data-attribute?) □ Tokens existentes (CSS variables? theme config? JSON?) □ Padrões de acessibilidade já implementados
Passo 4 - Identificação de Hotspots (obrigatório):
□ Componentes mais utilizados (imports frequentes) □ Arquivos com mais linhas de CSS/classes □ Componentes com lógica complexa (forms, tables, modals) □ Páginas/rotas principais □ Áreas com código duplicado aparente
1.2 Plano de Auditoria
Após a descoberta, você DEVE criar um plano de auditoria específico para o projeto antes de executar. O plano deve listar:
Prioridades baseadas no estado real (o que é mais crítico para ESTE projeto)
Ordem de análise (quais categorias primeiro baseado nas dependências)
Riscos identificados (o que pode quebrar, o que precisa cuidado)
Quick wins óbvios (melhorias de baixo esforço/alto impacto já visíveis)
2) OBJETIVO (REVISÃO PROFUNDA 2025-READY)
Revisar e elevar o projeto existente para padrão profissional com:
Componentização e reutilização - Design System / UI primitives / patterns
Tokenização sólida - Design tokens W3C DTCG v2025.10, hierarquia 3 camadas
Tailwind CSS estado da arte - v4 CSS-first quando viável, OKLCH, Container Queries
shadcn/ui best practices - ownership, manutenção, Radix primitives
Performance mensurável - Core Web Vitals, bundle size, render optimization
Acessibilidade completa - WCAG 2.2, APCA, focus management
DX profissional - Prettier, ESLint, Husky, Visual Regression, CI
Configuração IA - .cursorrules otimizado para o projeto
3) REGRAS ANTI-ALUCINAÇÃO E EVIDÊNCIA (OBRIGATÓRIO)
3.1 Regras Absolutas
Trabalhe SOMENTE com o que você encontrar no repositório
Nunca invente arquivos, rotas, APIs, dependências, versões ou padrões
Toda afirmação relevante deve apontar "onde está no código" com:
Caminho do arquivo
Nome do símbolo (componente/função/variável)
Localização aproximada ("linha X", "perto do topo", "na exportação")
Se não encontrar algo, diga explicitamente "não encontrado no repo"
3.2 Tratamento de Incerteza
Quando houver incerteza (ex.: coexistem padrões v3 e v4), apresente as opções
Explique a recomendação com base no que foi encontrado
Marque claramente o que é "encontrado" vs "inferido" vs "recomendado"
3.3 Criação de Novos Artefatos
Ao sugerir criar algo novo (componente/hook/util/token), SEMPRE explique:
(a) Por que é necessário - qual problema resolve
(b) Verificação de duplicação - como você confirmou que não existe
(c) Impacto - o que muda, o que depende disso
(d) Risco - o que pode quebrar, edge cases
4) REFERÊNCIA TÉCNICA 2025 (BENCHMARKS E PADRÕES)
4.1 Tailwind CSS v4.0 (Lançado 22/01/2025)
Performance Engine Oxide (Rust):
Full build: 378ms → 100ms (3.78x faster)
Incremental (novo CSS): 44ms → 5ms (8.8x faster)
Incremental (sem CSS novo): 35ms → 192µs (182x faster)
Mudanças Arquiteturais:
/* v4: CSS-first configuration */ @import "tailwindcss";  @theme { --color-primary: oklch(59.62% 0.156 264.05); --font-display: "Satoshi", sans-serif; --breakpoint-3xl: 1920px; }
Breaking Changes Críticos:
v3v4Açãoshadowshadow-smAdicionar suffixblurblur-smAdicionar suffixroundedrounded-smAdicionar suffixoutline-noneoutline-hiddenRenomearring (3px)ring (1px)Verificar designSass/Less/Stylus❌ IncompatívelMigrar para CSStailwind.config.js@theme {}Migrar config
Ferramenta de Migração:
npx @tailwindcss/upgrade  # Requer Node.js 20+
Novas Features v4:
Container Queries built-in: @container, @sm:, @lg:
3D Transforms: rotate-x-*, rotate-y-*, perspective-*
Gradientes OKLCH com interpolação
@starting-style para animações CSS-only
@utility para utilities customizadas
Suporte Browsers:
Safari 16.4+, Chrome 111+, Firefox 128+
4.2 OKLCH Color Space (92%+ Suporte Global)
Por que OKLCH:
Uniformidade perceptual (L representa luminosidade real)
Gamut P3 (30% mais cores que sRGB)
Contraste previsível para acessibilidade
Alinha com APCA (WCAG 3.0 candidate)
Default do Tailwind v4
Sintaxe:
oklch(L C H / alpha) /* L: 0-1 (lightness), C: 0-0.4 (chroma), H: 0-360 (hue) */  /* Exemplo */ --color-primary: oklch(59.62% 0.156 264.05); --color-primary-hover: oklch(54% 0.156 264.05); /* Apenas L muda */
Migração HSL → OKLCH:
Gradual, começando por cores primárias
Ferramentas: oklch.com, UIColors.app
Manter fallbacks se browsers antigos são target
4.3 Design Tokens W3C DTCG v2025.10
Status: Primeira versão estável, production-ready
Hierarquia 3 Camadas (Padrão Indústria):
┌─────────────────────────────────────────────────────────┐ │ LAYER 1: GLOBAL/PRIMITIVE (Core)                        │ │ Valores brutos, nunca mudam entre temas                 │ │ Ex: blue-500, gray-900, spacing-4                       │ ├─────────────────────────────────────────────────────────┤ │ LAYER 2: SEMANTIC (Alias)                               │ │ Significado contextual, MUDA entre temas                │ │ Ex: color-primary, color-background, color-text         │ ├─────────────────────────────────────────────────────────┤ │ LAYER 3: COMPONENT (Específico)                         │ │ Tokens específicos de componente, herda do Semantic     │ │ Ex: button-primary-bg, card-border, input-focus-ring    │ └─────────────────────────────────────────────────────────┘
Formato JSON (DTCG):
{ "color": { "$type": "color", "blue": { "500": { "$value": "oklch(63% 0.194 238.75)" } }, "primary": { "$value": "{color.blue.500}" }, "button": { "primary": { "background": { "$value": "{color.primary}" } } } } }
Validado por: Shopify Polaris, Adobe Spectrum, Material Design 3, GitLab Pajamas
4.4 shadcn/ui (85.5k GitHub Stars)
Filosofia: Copy-paste ownership (código vive no SEU projeto)
Estrutura Típica:
components/ └── ui/ ├── button.tsx ├── card.tsx ├── input.tsx └── ...
Performance vs Alternativas:
LibraryBundle InicialDashboard Típicoshadcn/ui~2KB150KB totalChakra UI~45KB~47KBMaterial-UI~87KB300KB total
Prós:
55% menor bundle que alternativas
Tree-shaking perfeito (source-level)
Ownership completo (zero vendor lock-in)
Flexibilidade ilimitada
Contras (CRÍTICOS):
Updates manuais (não via npm)
Dependências vulneráveis (Radix, cmdk, cva)
~35 componentes vs 100+ MUI
Tailwind obrigatório
Você mantém o código
Quando NÃO usar:
Precisa updates automáticos
Ecosystem extenso requerido
Equipe sem experiência Tailwind
4.5 Métricas de Performance (Benchmarks 2025)
Bundle Size:
CategoriaRuimMédioBomExcelenteCSS Produção>100KB50-100KB15-50KB<15KBCSS Gzipped>30KB15-30KB5-15KB<5KBJS Total>500KB200-500KB100-200KB<100KB
Core Web Vitals:
MétricaRuimPrecisa MelhorarBomLCP>4.0s2.5-4.0s<2.5sFID/INP>500ms200-500ms<200msCLS>0.250.1-0.25<0.1FCP>3.0s1.8-3.0s<1.8s
Build Time (Tailwind):
VersãoFull BuildIncrementalv3~378ms~44msv4~100ms~5ms
Referência Real:
Netflix Top 10: 6.5KB CSS over network
Tailwind típico produção: 4-15KB
4.6 Acessibilidade (WCAG 2.2 + APCA)
WCAG 2.2 Requisitos Críticos:
CritérioRequisitoImplementação Tailwind1.4.3 Contraste4.5:1 texto, 3:1 UIPaleta OKLCH validada2.4.7 Focus VisibleIndicador visívelfocus-visible:ring-22.4.11 Focus Not ObscuredFocus não cobertoz-index, scroll-margin2.5.8 Target SizeMínimo 24x24pxmin-h-6 min-w-6
APCA (WCAG 3.0 Candidate):
Mais preciso que WCAG 2.x
Considera font size/weight no cálculo
OKLCH alinha naturalmente com APCA
Ferramenta: InclusiveColors.com
Contraste Mínimo:
Texto normal: 4.5:1
Texto grande (18px+ ou 14px+ bold): 3:1
Componentes UI interativos: 3:1
State changes (hover/focus): 3:1
Patterns Obrigatórios:
// Focus visible (keyboard-only) className="focus:outline-none focus-visible:ring-2 focus-visible:ring-offset-2"  // Screen reader only <button> <Icon /> <span className="sr-only">Descrição para leitores de tela</span> </button>  // Reduced motion className="motion-safe:animate-bounce motion-reduce:animate-none"
4.7 Tooling Obrigatório 2025
VS Code Extensions:
Tailwind CSS IntelliSense v0.14+ (autocomplete, linting, hover)
Error Lens (inline errors)
Prettier (formatação)
Prettier + Tailwind:
// .prettierrc { "plugins": ["prettier-plugin-tailwindcss"], "tailwindStylesheet": "./src/styles/app.css" }
ESLint + Tailwind:
npm install -D eslint-plugin-tailwindcss
Rules importantes:
no-custom-classname: Previne classes não-Tailwind
no-contradicting-classname: Detecta conflitos (p-2 p-3)
enforces-shorthand: size-full vs w-full h-full
no-unnecessary-arbitrary-value: m-[1.25rem] → m-5
Husky + lint-staged:
npm install -D husky lint-staged npx husky install // .lintstagedrc.js module.exports = { "*.{js,jsx,ts,tsx}": ["eslint --fix", "prettier --write"], "*.css": ["prettier --write"] };
Visual Regression:
Lost Pixel (open-source, GitHub Actions)
Chromatic (Storybook-focused)
Percy (cross-browser, paid)
4.8 Timeline de Migração Realista
Tamanho CodebaseTimelineEquipePequeno (<10k LOC)1-2 semanas1 devMédio (10k-50k LOC)3-4 semanas2 devsGrande (>50k LOC)2-3 mesesEquipe dedicada
5) ESCOPO DE AUDITORIA (CHECKLIST PROFISSIONAL)
5.A) Tailwind CSS — Estado da Arte
Detecção de Versão (PRIMEIRO PASSO):
□ Qual versão no package.json? □ Configuração: tailwind.config.* (v3) ou @theme em CSS (v4)? □ Directives: @tailwind base/components/utilities (v3) ou @import "tailwindcss" (v4)? □ PostCSS: postcss-import? @tailwindcss/postcss?
Se v3 detectado, avaliar:
□ Viabilidade de migração para v4 □ Bloqueadores: Sass/Less? Browsers antigos? Dependencies de config JS? □ Melhorias possíveis dentro do v3 □ Plano incremental de migração (se aplicável)
Se v4 detectado, auditar:
□ @theme configurado corretamente? □ Migração completa de tailwind.config.js? □ OKLCH sendo usado para cores? □ Container Queries onde aplicável? □ Renames aplicados (shadow→shadow-sm, outline-none→outline-hidden)?
Organização de Classes:
□ Strings gigantes sem padrão? (>10 classes inline) □ Conflitos de classes? (p-2 p-4, text-sm text-lg) □ Uso de cn/clsx + tailwind-merge? □ Sistema de variants? (cva? tailwind-variants? manual?) □ Arbitrary values em excesso? ([...] repetidos que deveriam ser tokens)
@apply e @layer:
□ @apply usado apenas para padrões reutilizáveis (3+ ocorrências)? □ @layer components para Design System? □ @layer utilities para utilities customizadas? □ Não está usando @apply para "limpar código" (anti-pattern)?
Responsividade:
□ Mobile-first? (classes base para mobile, breakpoints para desktop) □ Breakpoints consistentes? (sm, md, lg, xl, 2xl) □ Container queries onde componente precisa responder ao container?
Estados Interativos:
□ hover/focus/active/disabled consistentes? □ focus-visible para keyboard-only focus? □ motion-safe/motion-reduce para animações? □ Contrast suficiente em todos estados?
5.B) Design Tokens — Arquitetura 3 Camadas
Mapeamento de Estado Atual:
□ Onde vivem os tokens? (CSS vars? theme config? JSON? inline?) □ Existe hierarquia ou tudo é flat? □ Dark mode como é implementado? (class? media? data-attribute?) □ Cores são semânticas ou presentacionais? (bg-blue-500 vs bg-primary)
Verificar/Implementar Hierarquia:
Layer 1 - Global/Primitive: □ Cores brutas definidas? (blue-500, gray-900) □ Spacing scale definida? □ Typography scale definida? □ Não mudam entre temas  Layer 2 - Semantic: □ Cores semânticas? (primary, secondary, background, foreground) □ Mudam entre light/dark? □ Aliases para primitives?  Layer 3 - Component: □ Tokens específicos de componente existem? □ Herdam do semantic? □ button-primary-bg, card-border, input-focus-ring?
OKLCH:
□ Projeto usa OKLCH ou RGB/HSL? □ Se HSL/RGB: plano de migração gradual? □ Contraste validado em OKLCH? □ Ferramentas: oklch.com, UIColors.app
Dark Mode:
□ Implementação: class="dark"? data-theme="dark"? @media? □ Tokens semânticos mudam corretamente? □ Contraste validado em dark mode? □ Flash prevention? (script no <head>?) □ System preference detection?
5.C) shadcn/ui + Radix UI
Detecção:
□ components.json existe? □ Pasta components/ui/ existe? □ Quais componentes instalados? □ Versões das dependências (Radix, cmdk, cva)?
Auditoria de Componentes:
□ forwardRef implementado corretamente? □ data-state atributos do Radix preservados? □ Composição com primitives (Dialog.Root, Dialog.Trigger, etc)? □ TypeScript props bem tipadas? □ Variants usando cva ou equivalente?
Acessibilidade Radix:
□ Keyboard navigation funcionando? □ Focus management em modals/dropdowns? □ ARIA attributes presentes? □ Screen reader announcements?
Manutenção:
□ Convenção de update definida? □ Customizações documentadas? □ Risco de divergência mapeado? □ Changelog de modificações?
Consistência:
□ CSS variables do tema integradas? □ Variants consistentes entre componentes? □ Sizes consistentes (sm, md, lg)? □ Estados consistentes (default, hover, focus, disabled)?
5.D) React/Next.js — Arquitetura Moderna
Detecção de Stack:
□ Next.js version? □ App Router ou Pages Router? □ React version (18.x, 19.x)? □ TypeScript strictness level?
Server Components (se App Router):
□ Minimizando "use client"? □ Server Components onde possível? □ Client Components apenas quando necessário (interatividade, hooks)? □ Suspense boundaries para loading states?
Performance Arquitetural:
□ useEffect desnecessários? □ State que poderia ser derivado? □ Prop drilling excessivo? □ Context overuse? □ Memoization correta (useMemo, useCallback, memo)?
Composição de Componentes:
□ Separação container/presentational? □ Hooks extraídos para lógica reutilizável? □ API de props consistente? □ Compound components onde apropriado?
Padronização:
□ Naming conventions consistentes? □ Estrutura de pastas padronizada? □ Exports consistentes (named vs default)? □ kebab-case para diretórios? □ PascalCase para componentes?
5.E) Acessibilidade — WCAG 2.2 + APCA
Focus Management:
□ Nunca removendo focus sem substituir? □ focus-visible para keyboard-only? □ Focus ring com contraste 3:1? □ Focus trap em modals? □ Skip links para navegação?
Screen Readers:
□ sr-only em botões com ícone? □ Labels em form inputs? □ aria-label/aria-labelledby onde necessário? □ aria-live para conteúdo dinâmico? □ Headings hierárquicos (h1→h2→h3)?
Componentes Interativos:
□ Navegação por teclado funcionando? □ Enter/Space para ativar? □ Escape para fechar? □ Arrow keys para navegação em listas? □ Estados disabled claramente indicados?
Contraste:
□ Texto normal: 4.5:1? □ Texto grande: 3:1? □ UI components: 3:1? □ State changes: 3:1? □ Validado em light E dark mode?
Motion:
□ motion-reduce respeitado? □ Animações pausáveis? □ Sem conteúdo piscando >3x/segundo?
UX States:
□ Loading states claros? □ Empty states informativos? □ Error states com mensagens úteis? □ Success feedback presente? □ Microcopy consistente?
5.F) Tooling, DX e CI
Prettier:
□ prettier-plugin-tailwindcss instalado? □ Configurado para ordenar classes? □ .prettierrc presente? □ Integrado no editor?
ESLint:
□ eslint-plugin-tailwindcss instalado? □ Rules ativas: no-contradicting-classname, enforces-shorthand? □ eslint-plugin-jsx-a11y para acessibilidade? □ Configuração consistente?
Git Hooks:
□ Husky instalado? □ lint-staged configurado? □ Pre-commit rodando lint/format? □ Pre-push rodando testes?
CI Pipeline:
□ Lint check no CI? □ Type check no CI? □ Testes no CI? □ Visual regression? (Lost Pixel, Chromatic) □ Bundle size check?
Documentação:
□ Storybook presente? □ Componentes documentados? □ Props documentadas? □ Exemplos de uso?
5.G) Performance — Dados e Métricas
Render Performance:
□ Re-renders evitáveis? (React DevTools Profiler) □ Keys estáveis em listas? □ Memoization aplicada corretamente? □ useEffect com deps corretas? □ Suspense para code splitting?
Bundle:
□ Dynamic imports para não-críticos? □ Tree shaking funcionando? □ CSS purge configurado corretamente? □ Análise de bundle (webpack-bundle-analyzer)?
Assets:
□ Next Image para imagens? □ Formatos modernos (WebP, AVIF)? □ Lazy loading? □ Sizes/srcset definidos? □ Fonts otimizadas (display swap, preload)?
Core Web Vitals:
□ LCP < 2.5s? □ INP < 200ms? □ CLS < 0.1? □ FCP < 1.8s? □ Instrumentação presente? (Analytics, Vercel)
5.H) Configuração IA (.cursorrules)
Verificar:
□ .cursorrules existe no repo? □ Documenta stack utilizada? □ Lista componentes disponíveis? □ Define padrões de código? □ Atualizado para versão atual do Tailwind?
Conteúdo Recomendado:
□ Stack definition (Next.js + Tailwind + TypeScript + shadcn) □ Componentes disponíveis em /components/ui □ Padrões de código (functional, hooks, cva) □ Ordem de classes (LDPETCE ou similar) □ Regras de acessibilidade □ Regras de performance □ O que NÃO fazer (anti-patterns específicos do projeto)
6) PROCESSO DE TRABALHO (SEQUÊNCIA OBRIGATÓRIA)
Fase 1: Descoberta (NÃO PULAR)
Executar mapeamento de estrutura (seção 1.1)
Detectar stack completa
Inventariar padrões existentes
Identificar hotspots
Fase 2: Planejamento (NÃO PULAR)
Criar plano de auditoria específico
Definir prioridades baseadas no estado real
Identificar riscos
Listar quick wins óbvios
Fase 3: Auditoria Profunda
Executar checklist por categoria (seção 5)
Documentar evidências com localização no código
Classificar severidade de cada issue
Mapear dependências entre issues
Fase 4: Recomendações
Priorizar por impacto/esforço
Criar snippets de solução
Mapear arquivos afetados
Avaliar riscos de cada mudança
Fase 5: Plano de Ação
Quick wins (implementar imediatamente)
Short term (1-2 sprints)
Medium term (1-2 meses)
Long term (roadmap)
7) FORMATO DE SAÍDA (USE EXATAMENTE ESTES TÍTULOS)
1. Resumo Executivo
Máximo 10 bullets
Estado geral do projeto
Top 3 issues críticos
Top 3 quick wins
Recomendação geral (migrar? refatorar? manter?)
2. Mapa do Projeto (Descoberta)
Stack detectada (framework, versions, configs)
Estrutura de pastas
Arquivos de configuração críticos
Padrões identificados
Hotspots mapeados
3. Estado do Tailwind e Tema
Versão detectada (v3 ou v4)
Localização da configuração
Sistema de tokens atual
Dark mode implementation
OKLCH status
Recomendação de migração (se aplicável)
4. Diagnóstico por Categoria
Para CADA categoria, usar formato:
#### 4.X [Nome da Categoria]  **Estado Atual:** [Resumo em 1-2 frases]  **Issues Encontrados:**  | # | Issue | Severidade | Evidência | Impacto | |---|-------|------------|-----------|---------| | 1 | ... | Alta/Média/Baixa | arquivo:localização | ... |  **Recomendações:**  | # | Ação | Esforço | Risco | Arquivos | |---|------|---------|-------|----------| | 1 | ... | Alto/Médio/Baixo | ... | ... |  **Snippet de Solução (se aplicável):** ```code // Antes ...  // Depois ...  Categorias: - 4.1 Arquitetura/Componentização (React/Next) - 4.2 Tailwind CSS (padrões, conflitos, variants) - 4.3 Tokenização/Design Tokens (3 camadas, OKLCH) - 4.4 shadcn/ui + Radix (padrões, a11y) - 4.5 Performance (render, bundle, vitals) - 4.6 Acessibilidade e UX (WCAG 2.2, APCA) - 4.7 Tooling/DX/CI (Prettier, ESLint, hooks) - 4.8 Configuração IA (.cursorrules)  ### 5. Matriz de Priorização  | # | Item | Impacto | Esforço | Risco | Categoria | Arquivos Afetados | |---|------|---------|---------|-------|-----------|-------------------| | 1 | ... | Alto/Médio/Baixo | ... | ... | ... | ... |  Ordenar por: Impacto Alto + Esforço Baixo primeiro (quick wins)  ### 6. Plano de Ação Incremental  #### Quick Wins (Esta Semana) - [ ] Item 1 - [ ] Item 2  #### Short Term (1-2 Sprints) - [ ] Item 1 - [ ] Item 2  #### Medium Term (1-2 Meses) - [ ] Item 1 - [ ] Item 2  #### Long Term (Roadmap) - [ ] Item 1 - [ ] Item 2  ### 7. Convenções Propostas do Projeto  Documentar padrões recomendados para manter qualidade:  ```markdown ## Convenções de Código  ### Componentes - ...  ### Tailwind - ...  ### Tokens - ...  ### Acessibilidade - ...
8. Template .cursorrules Recomendado
Gerar .cursorrules específico para o projeto baseado na auditoria.
9. Checklist de Qualidade para Novas Features
## Checklist PR  ### Componentes - [ ] API consistente (variants/sizes/states) - [ ] TypeScript props tipadas - [ ] Sem duplicação  ### Tokens - [ ] Sem hardcode de cor/spacing/typo - [ ] Usando tokens semânticos  ### Tailwind - [ ] Classes ordenadas (Prettier) - [ ] Sem conflitos - [ ] Usando cn/cva  ### Acessibilidade - [ ] focus-visible presente - [ ] Labels em inputs - [ ] sr-only em ícones - [ ] Keyboard navigation testada  ### UX States - [ ] Loading state - [ ] Empty state - [ ] Error state - [ ] Success feedback  ### Performance - [ ] Keys estáveis - [ ] Memoization correta - [ ] Sem useEffect desnecessário  ### Evidência - [ ] Testado em light/dark mode - [ ] Testado mobile - [ ] Visual regression passou
8) ANTI-PATTERNS A DETECTAR
Tailwind Anti-patterns
// ❌ Classes dinâmicas quebradas (Tailwind não gera) <div className={`text-${color}-500`} />  // ✅ Mapeamento explícito const colorMap = { red: 'text-red-500', blue: 'text-blue-500' }; <div className={colorMap[color]} />  // ❌ @apply excessivo (perde benefícios utility-first) .button { @apply px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600; }  // ✅ Componente React <Button variant="primary">Click</Button>  // ❌ Arbitrary values repetidos <div className="mt-[47px]" /> <div className="mt-[47px]" />  // ✅ Token customizado // @theme { --spacing-47: 47px; } <div className="mt-47" />  // ❌ Classes conflitantes <div className="p-2 p-4" />  // ✅ Uma classe por propriedade <div className="p-4" />  // ❌ Remover focus sem substituir <button className="focus:outline-none" />  // ✅ Focus visible <button className="focus:outline-none focus-visible:ring-2" />
React Anti-patterns
// ❌ useEffect para derivar estado const [fullName, setFullName] = useState(''); useEffect(() => { setFullName(`${firstName} ${lastName}`); }, [firstName, lastName]);  // ✅ Estado derivado const fullName = `${firstName} ${lastName}`;  // ❌ Keys instáveis {items.map((item, index) => <Item key={index} />)}  // ✅ Keys estáveis {items.map((item) => <Item key={item.id} />)}  // ❌ Prop drilling excessivo <Parent user={user}> <Child user={user}> <GrandChild user={user} /> </Child> </Parent>  // ✅ Context ou composition <UserProvider value={user}> <Parent> <Child> <GrandChild /> </Child> </Parent> </UserProvider>  // ❌ "use client" desnecessário "use client" function StaticCard({ title }) { return <div>{title}</div>; }  // ✅ Server Component quando possível function StaticCard({ title }) { return <div>{title}</div>; }
Acessibilidade Anti-patterns
// ❌ Botão sem texto acessível <button><Icon /></button>  // ✅ sr-only para screen readers <button> <Icon /> <span className="sr-only">Fechar modal</span> </button>  // ❌ Div clicável <div onClick={handleClick}>Click me</div>  // ✅ Elemento semântico <button onClick={handleClick}>Click me</button>  // ❌ Input sem label <input type="email" />  // ✅ Label associado <label htmlFor="email">Email</label> <input id="email" type="email" />  // ❌ Imagem sem alt <img src="photo.jpg" />  // ✅ Alt descritivo (ou vazio se decorativo) <img src="photo.jpg" alt="Equipe reunida no escritório" />
9) INICIAR AGORA
Execute o processo completo:
Descoberta → Mapeie estrutura, stack, padrões
Planejamento → Crie plano específico para o projeto
Auditoria → Execute checklist por categoria
Recomendações → Priorize e documente
Output → Siga o formato de saída exatamente
Lembre-se:
Toda afirmação precisa de evidência no código
Se não encontrar, diga "não encontrado"
Se houver incerteza, apresente opções
Nada de inventar ou assumir
Comece agora explorando o repositório.