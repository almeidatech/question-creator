-- Migration: 001_create_question_sources
-- Description: Creates question_sources table for dual-corpus RAG isolation
-- Date: 2026-02-01
-- Author: @dev
-- ============================================================================

-- Create ENUM type for source_type (strict enforcement)
CREATE TYPE source_type_enum AS ENUM ('real_exam', 'ai_generated', 'expert_approved');

-- Create audit_log table if it doesn't exist (for tracking changes)
CREATE TABLE IF NOT EXISTS audit_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  table_name VARCHAR(100) NOT NULL,
  operation VARCHAR(20) NOT NULL CHECK (operation IN ('INSERT', 'UPDATE', 'DELETE')),
  record_id UUID NOT NULL,
  old_value JSONB,
  new_value JSONB,
  changed_by UUID,
  changed_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_audit_log_table_time
  ON audit_log(table_name, changed_at DESC);
CREATE INDEX IF NOT EXISTS idx_audit_log_record
  ON audit_log(record_id, table_name);

-- Create question_sources table (CRITICAL FOR RAG ISOLATION)
CREATE TABLE IF NOT EXISTS question_sources (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Foreign key to questions table
  question_id UUID UNIQUE NOT NULL,

  -- Source type (strictly enforced enum)
  -- real_exam: Questions from actual exams (RAG-eligible)
  -- ai_generated: Questions generated by Gemini API (NOT RAG-eligible)
  -- expert_approved: Expert-created questions (for Phase 2)
  source_type source_type_enum NOT NULL,

  -- RAG eligibility flag
  -- TRUE only for real_exam questions
  -- FALSE for all ai_generated (CRITICAL: prevents contamination)
  rag_eligible BOOLEAN NOT NULL DEFAULT false,

  -- Audit trail
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),

  -- Expert review timestamps (NULL until approved)
  approved_at TIMESTAMP,
  approved_by UUID,

  -- Constraints
  CONSTRAINT fk_question_sources_question
    FOREIGN KEY (question_id) REFERENCES questions(id) ON DELETE CASCADE,
  CONSTRAINT fk_question_sources_approved_by
    FOREIGN KEY (approved_by) REFERENCES users(id) ON DELETE SET NULL,

  -- Additional validation: ai_generated can NEVER have rag_eligible=true
  CONSTRAINT check_ai_generated_not_rag_eligible
    CHECK (NOT (source_type = 'ai_generated' AND rag_eligible = true))
);

-- ============================================================================
-- CRITICAL INDEXES FOR RAG PERFORMANCE
-- ============================================================================

-- Composite index for RAG queries (MOST CRITICAL)
-- Every RAG query MUST use: WHERE source_type='real_exam' AND rag_eligible=true
CREATE INDEX idx_qs_type_eligible
  ON question_sources(source_type, rag_eligible)
  WHERE rag_eligible = true;

-- Index for foreign key lookups
CREATE INDEX idx_qs_question_id
  ON question_sources(question_id);

-- Index for approved records (admin queries)
CREATE INDEX idx_qs_approved
  ON question_sources(approved_at DESC)
  WHERE approved_at IS NOT NULL;

-- ============================================================================
-- AUDIT TRIGGER: Logs all changes to question_sources
-- ============================================================================

CREATE OR REPLACE FUNCTION audit_question_sources_changes()
RETURNS TRIGGER AS $$
BEGIN
  -- Log UPDATE operations
  IF TG_OP = 'UPDATE' THEN
    INSERT INTO audit_log(table_name, operation, record_id, old_value, new_value, changed_by, changed_at)
    VALUES (
      'question_sources',
      'UPDATE',
      NEW.id,
      row_to_json(OLD),
      row_to_json(NEW),
      current_user_id(), -- Requires auth context in application
      NOW()
    );
    RETURN NEW;

  -- Log DELETE operations
  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO audit_log(table_name, operation, record_id, old_value, changed_by, changed_at)
    VALUES (
      'question_sources',
      'DELETE',
      OLD.id,
      row_to_json(OLD),
      current_user_id(),
      NOW()
    );
    RETURN OLD;
  END IF;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Drop trigger if it exists (idempotent)
DROP TRIGGER IF EXISTS trg_audit_question_sources_changes ON question_sources;

-- Create trigger on UPDATE
CREATE TRIGGER trg_audit_question_sources_changes
AFTER UPDATE OR DELETE ON question_sources
FOR EACH ROW
EXECUTE FUNCTION audit_question_sources_changes();

-- ============================================================================
-- DATA MIGRATION: Insert 13,917 real exam questions
-- ============================================================================

-- This migration inserts all real exam questions with:
-- - source_type='real_exam'
-- - rag_eligible=true
-- These are the ONLY questions eligible for RAG retrieval

INSERT INTO question_sources (question_id, source_type, rag_eligible, created_at)
SELECT
  id,
  'real_exam'::source_type_enum as source_type,
  true as rag_eligible,
  NOW()
FROM questions
WHERE source_type IS NULL OR source_type = 'real_exam'
ON CONFLICT (question_id) DO NOTHING;

-- ============================================================================
-- CONTAMINATION CHECK QUERY
-- ============================================================================
-- This query should ALWAYS return 0 if system is functioning correctly
-- If count > 0, system has been compromised (ai_generated marked as rag_eligible)
--
-- SELECT COUNT(*) as contamination_count
-- FROM question_sources
-- WHERE source_type = 'ai_generated' AND rag_eligible = true;
--
-- ALERT: If contamination_count > 0, trigger CRITICAL alert in monitoring system
-- ============================================================================

-- ============================================================================
-- VERIFICATION QUERIES (for testing)
-- ============================================================================

-- Verify real exam questions are marked correctly
-- SELECT COUNT(*) as real_exam_count
-- FROM question_sources
-- WHERE source_type='real_exam' AND rag_eligible=true;
-- Expected: 13,917

-- Verify no contamination possible
-- SELECT COUNT(*) as ai_generated_count
-- FROM question_sources
-- WHERE source_type='ai_generated' AND rag_eligible=true;
-- Expected: 0 (always)
