// Database types for question_sources and RAG system
// Strict typing for corpus isolation

import { z } from 'zod';

/**
 * Source type enum - CRITICAL for corpus isolation
 * - real_exam: Questions from actual exams (RAG-eligible only)
 * - ai_generated: Questions generated by Gemini (NEVER RAG-eligible)
 * - expert_approved: Expert-created questions (Phase 2)
 */
export enum SourceType {
  REAL_EXAM = 'real_exam',
  AI_GENERATED = 'ai_generated',
  EXPERT_APPROVED = 'expert_approved',
}

/**
 * Question source record from database
 * Maps questions to their source and RAG eligibility
 */
export interface QuestionSource {
  id: string; // UUID
  question_id: string; // UUID - UNIQUE constraint
  source_type: SourceType;
  rag_eligible: boolean; // CRITICAL: false for all ai_generated
  created_at: Date;
  approved_at: Date | null;
  approved_by: string | null; // UUID
}

/**
 * Audit log entry for compliance & security
 */
export interface AuditLogEntry {
  id: string; // UUID
  table_name: string;
  operation: 'INSERT' | 'UPDATE' | 'DELETE';
  record_id: string;
  old_value: Record<string, unknown> | null;
  new_value: Record<string, unknown> | null;
  changed_by: string | null; // UUID
  changed_at: Date;
}

/**
 * Zod schema for QuestionSource validation
 * Used in API responses and database operations
 */
export const questionSourceSchema = z.object({
  id: z.string().uuid(),
  question_id: z.string().uuid(),
  source_type: z.nativeEnum(SourceType),
  rag_eligible: z.boolean(),
  created_at: z.date(),
  approved_at: z.date().nullable(),
  approved_by: z.string().uuid().nullable(),
});

export type QuestionSourceInput = z.infer<typeof questionSourceSchema>;

/**
 * Schema for creating new question sources
 * Used when inserting AI-generated questions
 */
export const createQuestionSourceSchema = z.object({
  question_id: z.string().uuid(),
  source_type: z.nativeEnum(SourceType),
  rag_eligible: z.boolean(), // MUST validate: ai_generated => rag_eligible=false
}).refine(
  (data) => {
    // CRITICAL VALIDATION: ai_generated can NEVER have rag_eligible=true
    if (data.source_type === SourceType.AI_GENERATED && data.rag_eligible) {
      return false;
    }
    return true;
  },
  {
    message: 'AI-generated questions can NEVER be RAG-eligible (corpus contamination prevention)',
    path: ['rag_eligible'],
  }
);

export type CreateQuestionSourceInput = z.infer<typeof createQuestionSourceSchema>;

/**
 * Audit log schema
 */
export const auditLogSchema = z.object({
  id: z.string().uuid(),
  table_name: z.string(),
  operation: z.enum(['INSERT', 'UPDATE', 'DELETE']),
  record_id: z.string(),
  old_value: z.record(z.string(), z.unknown()).nullable(),
  new_value: z.record(z.string(), z.unknown()).nullable(),
  changed_by: z.string().uuid().nullable(),
  changed_at: z.date(),
});

export type AuditLog = z.infer<typeof auditLogSchema>;

